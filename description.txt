                Development of an abstract graph model of dependence, its visualization and application.


1. Preface Greeting
2. Principles of work
3. Connection rules
4. Graph events
5. Visualization
6. Applications


1. Foreword

    Hello, in this article I want to talk about the development of a nod widget on PySide, about what problems I had to face and how I solved them.

    For clarity, I will tell a little about the origins. About what the graph can be learned from the mathematical theory of graphs, this is the section of discrete mathematics whose main object of study is graphs. A graph is a collection of vertices connected by edges. Graphs can be directional, non-directional, mixed and isomorphic. As for the terminology, I just want to say that the theory of graphs has not yet settled, and in different publications the same terms can mean different things. We will call the vertices "nodes" (nodes), edges - "connections" (connection). In our case, we consider an acyclic directed graph (DAG). This is a graph in which there are no directed cycles, that is, paths that begin and end at the same vertex.




                                                Principles.

1) Each node has input and output ports, and there is a "brain" - the function "compute", which requests data from the input ports, performs some calculations and then writes the result to the output ports.

2) Noda should not know anything from the environment and never uses data that is external to her. All that she knows is her input and output ports and can request data from them or write them through the compute function.

    The node has input and output ports, each port has data from the previous rendering. In the event that the port is disconnected and remains in isolation, the algorithm using the data will take the value from the previous rendering.

3) Each port must have a binary dirty property. And service lists who influences whom. To establish these dependencies, the pinAffects function must be called.

    For example, if this is the output port of node "A", then it will be affected by some input port of this node. And at the moment of connection with the node "B", the out-port "A" will affect some kind of input nodes "B", etc. realizing the connection between the input and output ports of nodes. On the basis of such connections, the mechanism of dirty propogation will work for the optimal recalculation of the graph.

4) Output ports provide information only if they ask (getData). (lazy evaluation)

5) The data is forbidden to read / write to the line inside the compute function, there are special methods for this, getData, setData. Although, for example, in the graph plot mapping method, we access the data in a straight line to print out their value at the moment, without causing getData and not using the dirty_propagation mechanism.

6) Compute methods are called once for each node in depth from the end of the graph, taking into account dirty flags. Information about the order in which to call a comet for a block must be known to the graph, and it can be obtained by feeding the method to the node. It is necessary to take into account the situation of non-directional cycles.

7) Nodes of the same level do not depend on each other and are calculated in parallel or sequentially to choose. When all nodes of the same level are calculated, the next level nodes are calculated, etc. to end.

8) Ports will be divided according to the types of data they work with. You can not connect ports of incompatible data types.


                                                Rules.

- Only ports of different types (input and output) with compatible data types can be connected.
- The input port can only accept one link.
- The output port can communicate with many.
- The input port can not take a value from the output port of its own node. (Cyclic nodes are not present)
- When we write "special" nodes, in which the pins can be added in runtime, or you need to store something unique, you need to describe how to store and load such nodes, for example arrays or a node sequence, or a node comment. see the source code)


                                            Description of the events

1) The output port of the node "A" is connected to the input port of the node "B."

    At this moment, the lists of influence are filled in. Thefilled in
    lists of the graph are.
    A connection is created (graphically - the line connecting the ports).
    Data from the output port of the node "A" registered in the input port of node "B."
    Dirty flags are placed

2) Sv ide between ports exploded.

    are edited lists of influence.
    remove the links.

3) Change the value of INPUT node port.

    At this point, on official lists ports who influences whom exhibited dirty flags up to the end of the count, starting from the port where the data is changed.

4) Port zaprasht data.

    The dirty flag is checked, if true, then the graph prompts for the counting of the nodes, and they are recalculated. If false, the data from the last rendering is taken.

